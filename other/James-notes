1. Sample size, sigma2j, and k_j arguments. For power_CHE() and related functions, consider dropping the arguments related to sample size (or handling the conversion from sample size to sampling variance in a separate set of functions). This would a) simplify the functions slightly and b) allow the functions to be applied for other effect size metrics besides SMDs. DONE

2. Also consider simplifying the inputs for these quantities, using the following argument structure:

power_CHE <-
  function(J, tau2, omega2, beta, rho,
           var_df = c("Model", "Satt", "RVE"),
           sigma2_dist = NULL,

           n_ES_dist = NULL,

           alpha = c(.01, .05, .1),
           iterations = 100,
           average_power = TRUE,
           seed = NULL)

With this structure, the method for generating sigma2_j depends on the form of the input. If the input to sigma2_dist is just a single numeric value, so is.numeric(sigma2_dist), then this number will be used for all studies (i.e., a balanced design). If the input to sigma2_dist is a vector of numeric values, then sigma2_j will be generated by sampling at random (with replacement) from this vector (i.e., an empirical distribution). If the input to sigma2_dist is a function that takes J as an input and returns J random numbers, then the function will be used to generate sigma2_j values (i.e., a stylized distribution). For example, to generate sigma2_j from a gamma distribution, the input would be
sigma2_j = \(x) rgamma(x, shape = 5, rate = 10)
The structure of n_ES_dist could be designed similarly.

3. For power_CHE() and related functions, consider allowing the arguments J, tau2, omega2, beta, and rho to be single numbers or vectors with multiple values. If any of the arguments is a vector, then the function would create a fully crossed factorial grid for all combinations of values, and then evaluate power_CHE() for each row of the grid, similar to what is currently done in the first part of power_plot(). The output of power_CHE() could then be a tibble with one or multiple rows.

4. Would it simplify the code base to combine the functions power_CHE(), power_MLMA(), and power_CE() into a single function power_MADE() with an argument to specify the working model (or models)?

5. Comments 1-4 also apply to the MDES_*() and find_J_*() functions.

6. Consider simplifying the plotting functions so that the input is a grid of results (which can be generated using power_CHE() or related) and the function focuses on just creating a nicely formated and labeled ggplot object. The big disadvantage of the current design is that plot_power() and the other functions end up doing a lot of computation to generate estimates and display the results in a plot, but then there is no way to reference the underlying numeric results.
