1. Sample size, sigma2j, and k_j arguments. For power_CHE() and related functions, consider dropping the arguments related to sample size (or handling the conversion from sample size to sampling variance in a separate set of functions). This would a) simplify the functions slightly and b) allow the functions to be applied for other effect size metrics besides SMDs.

MHV: DONE

2. Also consider simplifying the inputs for these quantities, using the following argument structure:

power_CHE <-
  function(J, tau2, omega2, beta, rho,
           var_df = c("Model", "Satt", "RVE"),
           sigma2_dist = NULL,

           n_ES_dist = NULL,

           alpha = c(.01, .05, .1),
           iterations = 100,
           average_power = TRUE,
           seed = NULL)

MHV: DONE

With this structure, the method for generating sigma2_j depends on the form of the input. If the input to sigma2_dist is just a single numeric value, so is.numeric(sigma2_dist), then this number will be used for all studies (i.e., a balanced design). If the input to sigma2_dist is a vector of numeric values, then sigma2_j will be generated by sampling at random (with replacement) from this vector (i.e., an empirical distribution). If the input to sigma2_dist is a function that takes J as an input and returns J random numbers, then the function will be used to generate sigma2_j values (i.e., a stylized distribution). For example, to generate sigma2_j from a gamma distribution, the input would be
sigma2_j = \(x) rgamma(x, shape = 5, rate = 10)
The structure of n_ES_dist could be designed similarly.

MHV: DONE (first round). James will you check the accruracy of these functionalities?

3. For power_CHE() and related functions, consider allowing the arguments J, tau2, omega2, beta, and rho to be single numbers or vectors with multiple values. If any of the arguments is a vector, then the function would create a fully crossed factorial grid for all combinations of values, and then evaluate power_CHE() for each row of the grid, similar to what is currently done in the first part of power_plot(). The output of power_CHE() could then be a tibble with one or multiple rows.

MHV: I struggled to combine the power_MADE_engine2() and the power_MADE() functions as we talked about James, can you help me with this? Or at least should be an example of calling a function in itself.

4. Would it simplify the code base to combine the functions power_CHE(), power_MLMA(), and power_CE() into a single function power_MADE() with an argument to specify the working model (or models)?

MHV: DONE FOR POWER (first round)

5. Comments 1-4 also apply to the MDES_*() and find_J_*() functions.

MHV: Awaits James' revision of the power_MADE function (first round) to align these functions with the power_MADE function

6. Consider simplifying the plotting functions so that the input is a grid of results (which can be generated using power_CHE() or related) and the function focuses on just creating a nicely formated and labeled ggplot object. The big disadvantage of the current design is that plot_power() and the other functions end up doing a lot of computation to generate estimates and display the results in a plot, but then there is no way to reference the underlying numeric results.

MHV: Awaits James' revision of the power_MADE function (first round)




FURTHER COMMENTS AND NOTES (MHV):

I restructured the power_t function so that the alpha level gets its own column instead of being presented in the title of the power column

A general question: Should we add an argument in the power_MADE() function that allows the user to get the raw power data across all iteration for each set of vales of J, tau2, omega2 â€¦ etc.? Currently, it works in the power_MADE_engine2 function but not power_MADE


